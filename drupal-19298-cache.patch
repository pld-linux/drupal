--- includes/bootstrap.inc.orig	2005-04-08 09:22:33.000000000 -0500
+++ includes/bootstrap.inc	2005-04-08 17:43:57.000000000 -0500
@@ -9,6 +9,10 @@
 define('CACHE_PERMANENT', 0);
 define('CACHE_TEMPORARY', -1);
 
+define('CACHE_DISABLED', 0);
+define('CACHE_ENABLED_STRICT', 1);
+define('CACHE_ENABLED_LOOSE', 2);
+
 define('WATCHDOG_NOTICE', 0);
 define('WATCHDOG_WARNING', 1);
 define('WATCHDOG_ERROR', 2);
@@ -196,9 +200,37 @@ function variable_del($name) {
  *   The cache ID of the data to retrieve.
  */
 function cache_get($key) {
-  $cache = db_fetch_object(db_query("SELECT data, created, headers FROM {cache} WHERE cid = '%s'", $key));
+  global $user;
+  $sid = session_id();
+
+  // CACHE_ENABLED_LOOSE garbage collection
+  $cache_flush = variable_get('cache_flush', 0);
+  if ($cache_flush && ($cache_flush + variable_get('cache_flush_delay', 300) <= time())) {
+    // time to flush old cache data
+    db_query("DELETE FROM {cache} WHERE expire != %d AND expire <= %d", CACHE_PERMANENT, $cache_flush);
+    variable_set('cache_flush', 0);
+  }
+
+  $cache = db_fetch_object(db_query("SELECT data, created, headers, expire FROM {cache} WHERE cid = '%s'", $key));
   if (isset($cache->data)) {
-    $cache->data = db_decode_blob($cache->data);
+    // if data is permanent or using strict caching, always return data
+    if ($cache->expire == CACHE_PERMANENT || variable_get('cache', CACHE_DISABLED) == CACHE_ENABLED_STRICT) {
+      $cache->data = db_decode_blob($cache->data);
+    }
+    /* if using loose caching, validate data is current before we return it by
+    ** making sure the cache entry was created before the timestamp in the
+    ** current session's cache timer.  The cache variable is already loaded
+    ** into the $user object by sess_read in session.inc
+    */
+    else {
+      if ($user->cache > $cache->created) {
+        // this cache data is too old and thus not valid for us, ignore it
+        return 0;
+      }
+      else {
+        $cache->data = db_decode_blob($cache->data);
+      }
+    }
     return $cache;
   }
   return 0;
@@ -235,16 +267,44 @@ function cache_set($cid, $data, $expire 
  * Expire data from the cache.
  *
  * @param $cid
- *   If set, the cache ID to delete. Otherwise, all cache entries that can expire
- *   are deleted.
+ *   If set, the cache ID to delete. Otherwise, all cache entries that can 
+ *   expire are deleted.
  *
  * @param $wildcard
  *   If set to true, the $cid is treated as a substring to match rather than a
  *   complete ID.
  */
 function cache_clear_all($cid = NULL, $wildcard = false) {
+  global $user;
+  $sid = session_id();
+
   if (empty($cid)) {
-    db_query("DELETE FROM {cache} WHERE expire != %d AND expire < %d", CACHE_PERMANENT, time());
+    if (variable_get('cache', CACHE_DISABLED) == CACHE_ENABLED_STRICT) {
+      // strict caching, flush all temporary cache entries
+      db_query("DELETE FROM {cache} WHERE expire != %d AND expire < %d", CACHE_PERMANENT, time());
+    }
+    else {
+      $cache_flush = variable_get('cache_flush', 0);
+      /* loose caching, only flush temporary cache entries that have been
+      ** invalidated for more than maximum allowable time.
+      */
+      if ($cache_flush && ($cache_flush + variable_get('cache_flush_delay', 300) <= time())) {
+        /* only flush cache data older than $cache_flush, as newer data may
+        ** now be valid.
+        */
+        db_query("DELETE FROM {cache} WHERE expire != %d AND expire <= %d", CACHE_PERMANENT, $cache_flush);
+        variable_set('cache_flush', 0);
+      }
+      /* invalidate temporary cache data only for current user/session.  We
+      ** set $user->cache, which gets saved into the sessions table by 
+      ** sess_write() in session.inc.
+      */
+      $user->cache = time();
+      if (variable_get('cache_flush', 0) == 0) {
+        // set timestamp to know which cache entries we eventually clear
+        variable_set('cache_flush', time());
+      }
+    }
   }
   else {
     if ($wildcard) {
--- includes/session.inc.orig	2005-04-08 17:33:12.000000000 -0500
+++ includes/session.inc	2005-04-08 17:33:38.000000000 -0500
@@ -45,7 +45,7 @@ function sess_read($key) {
 function sess_write($key, $value) {
   global $user;
 
-  db_query("UPDATE {sessions} SET uid = %d, hostname = '%s', session = '%s', timestamp = %d WHERE sid = '%s'", $user->uid, $_SERVER["REMOTE_ADDR"], $value, time(), $key);
+  db_query("UPDATE {sessions} SET uid = %d, cache = %d, hostname = '%s', session = '%s', timestamp = %d WHERE sid = '%s'", $user->uid, $user->cache, $_SERVER["REMOTE_ADDR"], $value, time(), $key);
 
   return '';
 }
--- modules/system.module.orig	2005-04-08 09:16:48.000000000 -0500
+++ modules/system.module	2005-04-08 09:19:50.000000000 -0500
@@ -37,7 +37,7 @@ function system_help($section) {
       <pre>     00 * * * * /home/www/drupal/scripts/cron-lynx.sh</pre>
       Note that it is essential to access <code>cron.php</code> using a browser on the web site's domain; do not run it using command line PHP and avoid using <code>localhost</code> or <code>127.0.0.1</code> or some of the environment variables will not be set correctly and features may not work as expected.</p>
       <h3><a id=\"cache\">Cache</a></h3>
-      <p>Drupal has a caching mechanism which stores dynamically generated web pages in a database.  By caching a web page, Drupal does not have to create the page each time someone wants to view it, instead it takes only one SQL query to display it, reducing response time and the server's load.  Only pages requested by \"anonymous\" users are cached.  In order to reduce server load and save bandwidth, Drupal stores and sends cached pages compressed.</p>", array('%base_url' => $base_url, '%cron-link' => "<a href=\"$base_url/cron.php\">$base_url/cron.php</a>", '%lynx' => 'http://lynx.browser.org', '%wget' => 'http://www.gnu.org/software/wget/wget.html' ));
+      <p>Drupal has a caching mechanism which stores dynamically generated web pages in a database.  By caching a web page, Drupal does not have to create the page each time someone wants to view it, instead it takes only one SQL query to display it, reducing response time and the server's load.  Only pages requested by \"anonymous\" users are cached.  In order to reduce server load and save bandwidth, Drupal stores and sends cached pages compressed.  Drupal supports by strict caching and loose caching.  Strict caching immediately deletes cached data as soon as it becomes invalid for any user.  Loose caching delays the deletion of cached data to provide better performance for high traffic sites.</p>", array('%base_url' => $base_url, '%cron-link' => "<a href=\"$base_url/cron.php\">$base_url/cron.php</a>", '%lynx' => 'http://lynx.browser.org', '%wget' => 'http://www.gnu.org/software/wget/wget.html' ));
     case 'admin/modules#description':
       return t('Handles general site configuration for administrators.');
   }
--- database/database.mysql.orig	2005-04-08 09:21:50.000000000 -0500
+++ database/database.mysql	2005-04-08 09:18:25.000000000 -0500
@@ -574,6 +574,7 @@
   sid varchar(32) NOT NULL default '',
   hostname varchar(128) NOT NULL default '',
   timestamp int(11) NOT NULL default '0',
+  cache int(11) NOT NULL default '0',
   session longtext,
   KEY uid (uid),
   PRIMARY KEY (sid),
--- database/database.pgsql.orig	2005-04-08 09:21:55.000000000 -0500
+++ database/database.pgsql	2005-04-08 09:18:25.000000000 -0500
@@ -587,6 +587,7 @@
   sid varchar(32) NOT NULL default '',
   hostname varchar(128) NOT NULL default '',
   timestamp integer NOT NULL default '0',
+  cache integer NOT NULL default '0',
   session text,
   PRIMARY KEY (sid)
 );
--- modules/system.module~	2005-12-20 17:03:28.000000000 +0200
+++ modules/system.module	2005-12-20 17:04:57.000000000 +0200
@@ -226,7 +226,7 @@ function system_view_general() {
   $output .= form_group(t('Error handling'), $group);
 
   // Caching:
-  $group  = form_radios(t('Cache support'), 'cache', variable_get('cache', 0), array(t('Disabled'), t('Enabled')), t('Enable or disable the caching of rendered pages.  When caching is enabled, Drupal will flush the cache when required to make sure updates take effect immediately.  Check the <a href="%documentation">cache documentation</a> for information on Drupal\'s cache system.', array('%documentation' => url('admin/help/system#cache', NULL, NULL, 'cache'))));
+  $group  = form_radios(t('Cache support'), 'cache', variable_get('cache', CACHE_DISABLED), array(CACHE_DISABLED => t('Disabled'), CACHE_ENABLED_STRICT => t('Strict'), CACHE_ENABLED_LOOSE => t('Loose')), t('Enable or disable the caching of rendered pages.  When strict caching is enabled, Drupal will flush the entire cache when required to make sure updates take effect immediately.  When loose caching is enabled, Drupal will delay the flushing of the entire cache for several minutes, immediately flushing the cache only for specific users.  Loose caching is intended to improve performance on high traffic sites.  Check the <a href="%documentation">cache documentation</a> for information on Drupal\'s cache system.', array('%documentation' => url('admin/help', NULL, NULL, 'cache'))));
 
   $output .= form_group(t('Cache settings'), $group);
 
--- database/updates.inc~	2005-12-20 17:03:28.000000000 +0200
+++ database/updates.inc	2005-12-20 17:07:37.000000000 +0200
@@ -108,6 +108,7 @@ $sql_updates = array(
   "2005-04-14" => "update_129",
   "2005-05-06" => "update_130",
   "2005-05-07" => "update_131"
+,  "2005-12-20" => "update_132"
 );
 
 function update_32() {
@@ -2394,6 +2395,17 @@ function update_131() {
   return $ret;
 }
 
+function update_132() {
+  $ret = array();
+  if ($GLOBALS['db_type'] == 'mysql') {
+    $ret[] = update_sql("ALTER TABLE sessions ADD cache int(11) NOT NULL default '0' AFTER timestamp");
+  }
+  elseif ($GLOBALS['db_type'] == 'pgsql') {
+    $ret[] = update_sql("ALTER TABLE sessions ADD cache int(11) NOT NULL default '0' AFTER timestamp");
+  }
+  return $ret;
+}
+
 function update_sql($sql) {
   $edit = $_POST["edit"];
   $result = db_query($sql);
